# System Overview

This document explains how the Quasar-based **Lib** frontend is organised and how its pieces interact. It complements the shorter README and `WORKFLOW.md` files with deeper information about the architecture.

## Build and Configuration

The Quasar CLI drives the build. Key options live in `quasar.conf.js` where environment variables such as `API_URL`, `API_PATH` and `STORAGE_KEY` are defined. During `quasar dev` the app serves on port **8050**. These variables control all API requests via the services layer.

```
APP_NAME   = 'Lib'
API_URL    = 'http://localhost:8060/'
API_PATH   = 'http://localhost:8060/api/'
STORAGE_KEY= 'LIB'
```

Running `quasar dev` starts the development server, while `quasar build` generates production files under `dist/`.

## Directory Layout

```
public/              - static files copied directly to the build output
src/
  assets/            - images, icons and other design assets
  boot/              - Quasar boot files executed before the app mounts
  components/        - reusable Vue components
  composables/       - reusable logic for pages (list, add, edit, view, etc.)
  css/               - global Sass/CSS files
  layouts/           - layout shells wrapping page content
  pages/             - page components grouped per resource
  router/            - Vue Router configuration
  services/          - modules handling API requests, i18n and storage
  stores/            - Pinia stores for UI state and generic page data
  statics/           - extra files copied as-is during the build
  utils.js           - general helper functions
```

The structure follows the conventions generated by RadSystems with Quasar, so each resource (like `books` or `authors`) has its own folder under `src/pages/` with `list.vue`, `view.vue`, `add.vue` and `edit.vue` files.

## Application Boot Sequence

1. **`src/main.js`** runs first. It registers global components such as `NiceSelect`, exposes utilities (`$api`, `$localStore`, `$menus`, `$utils`) and configures default props for Quasar components (`QInput`, `QSelect`, `QBtn`).
2. Boot files in **`src/boot/`** then execute:
   - **`i18n.js`** loads the language file specified by `StorageService.getLocale()` and exposes `$t` for translations.
   - **`axios.js`** attaches the global axios instance (`ApiService.axios`) to Vue so components may use `this.$axios`.
   - **`filters.js`** registers template filters (date formatting, currency, truncate, etc.).
   - **`auth.js`** is a placeholder (`//auth not implemented`).
3. Finally the root Vue instance mounts and the router takes control.

## Router

Routes live in `src/router/index.js`. The main `MainLayout.vue` layout wraps all pages. Each resource defines routes for CRUD operations. Example:

```javascript
{
  path: '/books',
  name: 'bookslist',
  component: () => import('pages/books/list.vue'),
  props: route => passRouteToProps(route)
}
```

Unknown paths fall through to a catch‑all route rendering `pages/errors/pagenotfound.vue`.

## Stores

Pinia is initialised in `src/stores/index.js`. Two store modules are included:

- **`app.js`** – global UI state (drawers, dialogs, loading indicators and error messages). Components use `useAppStore` via the `useApp` composable.
- **`page.js`** – a factory that creates per-page stores to handle record lists and forms. These stores keep pagination info, selected items and cached API results.

Composables call these stores to keep the UI reactive.

## Composables

The composables encapsulate stateful logic for pages:

- **`useListPage`** manages filters, pagination and deletion for list pages. It loads records from the API and can append more when scrolling.
- **`useAddPage`**, **`useEditPage`** and **`useFormPage`** handle form submission, validation (using Vuelidate) and mapping select inputs.
- **`useViewPage`** loads a single record for view screens.
- **`useApp`** wraps global helpers around `useAppStore` to show notifications or open dialogs.

Pages import these composables to reuse behaviour rather than repeating logic in every component.

## Services

- **`api.js`** configures Axios with `API_PATH` and sets an authorization header if a token exists in storage. It exposes helper methods (`get`, `post`, `put`, `delete`, `download`) and integrates `axios-cache-interceptor`.
- **`storage.js`** reads and writes tokens or locale information to either `localStorage` or `sessionStorage` under the key defined by `STORAGE_KEY`.
- **`i18n.js`** loads translation JSON files and provides a `t` function used by Vue templates. Boot code registers `$t`.
- **`validators.js`** re-exports Vuelidate validators but wraps them with translation support using the `$t` function.

## Menus and Table Headers

`src/menus.js` exports a large object containing sidebar links and table column definitions. List pages import the headers to ensure consistent column labels and order. The layout component iterates over `AppMenus.navbarSideLeft` to build the side drawer.

## Utilities

`src/utils.js` defines numerous helpers: generating UUIDs, formatting dates, debouncing functions, serialising query strings and building file URLs. Global methods like `$utils.capitalize` are widely used inside components and composables.

## How the Parts Work Together

1. When a route such as `/books` is visited, Vue Router loads `pages/books/list.vue` inside `MainLayout.vue`.
2. That page uses `useListPage` which in turn creates/uses a page store from `usePageStore('books')`.
3. `useListPage` builds the API URL using `utils.setApiPath()` and asks `ApiService` to fetch records. The service prefixes the request with `API_PATH` and attaches any stored token.
4. Fetched data is stored in the page store so the UI updates reactively. Pagination state is updated based on the response.
5. Forms (`add.vue` or `edit.vue`) use `useAddPage`/`useEditPage`. When submitted they call `ApiService.post()` and upon success update the store so list pages reflect the new data.
6. Global dialogs or drawers are controlled via `useAppStore`, allowing components to open modals or side panels without manually passing props.

Everything centres around the stores and services: composables manipulate store state, components consume those stores, and the services handle external communication.

## Development Flow

Refer to `WORKFLOW.md` for the original scaffold instructions and available API endpoints. In short:

```bash
npm install       # install dependencies
quasar dev        # run locally on http://localhost:8050
quasar build      # generate production assets
```

API endpoints follow the pattern `<resource>/<action>` (e.g. `books/add`, `authors/edit/{id}`) and are documented in `WORKFLOW.md`.

---

This expanded overview should help developers quickly understand how each folder and feature fits into the Lib project.
